---
title: Занятие 35
description: «REST, RPC и работа с внешними API»
---

# OTUS

## Javascript Basic

<!-- v -->

## REST, RPC и работа с внешними API

<!-- v -->

### План вебинара:

- Request–Response APIs
- fetch vs XHR
- правила REST
- сторонние апи
<!-- s -->

### Request–Response APIs

<!-- v -->

#### Основные свойства Request–Response API

- API предоставляется посредством HTTP веб сервера
- API предоставляет набор эндпоинтов
- клиент делает http запрос **request** на нужные эндпоинты и получает ответ **response**
- response обычно в формате JSON или XML
<!-- v -->

#### Самые распространенные request-response API

- REST
- RPC
- GraphQL
<!-- s -->

### REST

<!-- v -->

_Representational State Transfer (REST)_ - самый популярный подход для разработки API в наше время

Применяется такими компаниями, как Google, Stripe, Twitter, Github и т.д.

<!-- v -->

REST - это про resources и методы работы с этими ресурсами

**Resource** - это объект, который может быть идентифицирован, назван, адресован или обработан в сети.

<!-- v -->

REST представляет данные в виде ресурсов и использует стандартные методы HTTP для представления операций над этими ресурсами

<!-- v -->

#### Примеры ресурсов

Stripe API представляет пользователей (customers), расходы (charges), платежный баланс (balance), возмещение денежных средств (refunds), события (events), файлы (files) и выплаты (payouts) как ресурсы.

<!-- v -->

#### Некоторые общие правила, которым следуют REST API:

<!-- v -->

Ресурсы являются частью URL-адресов, например **/users**

<!-- v -->

Для каждого ресурса обычно реализуются два URL-адреса: один для коллекции, например **/users**, и один для определенного элемента, например **/users/U123**

<!-- v -->

Существительные вместо глаголов. Например, вместо **/getUserInfo/U123** используется **/users/U123**

<!-- v -->

- **C**reate - используйте POST для создания новых ресурсов
- **R**ead - используйте GET для чтения ресурсов. Запросы GET никогда не изменяют состояние ресурса. У них нет побочных эффектов; метод GET имеет семантику только для чтения. GET идемпотентен. Следовательно, вы можете кэшировать вызовы.
- **U**pdate - используйте PUT для замены ресурса и PATCH для частичного обновления существующих ресурсов.
- **D**elete - используйте DELETE для удаления существующих ресурсов.
  <!-- v -->
  Стандартные коды состояния ответа HTTP возвращаются сервером, указывая на успех или неудачу.
- **2XX** успех
- **3XX** перемещение ресурса
- **4XX** ошибки на стороне клиента (например, отсутствие обязательного параметра или слишком много запросов)
- **5XX** ошибки на стороне сервера
  <!-- v -->
  CRUD операции, HTTP глаголы и REST соглашения

<img src="./images/REST_CRUD_operations.png" alt="CRUD операции, HTTP глаголы, and REST соглашения">
  <!-- v -->
  HTTP-запрос для получение платежа через Stripe API

```
GET /v1/charges/ch_CWyutlXs9pZyfD
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

HTTP-запрос для создание списания средств через Stripe API

```
POST /v1/charges
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

<!-- v -->

Ресурс, который может существовать только в другом ресурсе, должен быть представлен как сабресурс, а не как ресурс верхнего уровня в URL-адресе.

<!-- v -->

Например, GitHub API использует сабресурсы для представления отношений в различных API:

<div style="text-align: left"> Создать issue</div>

```
POST /repos/:owner/:repo/issues
```

<div style="text-align: left"> Получить определенный issue</div>

```
GET /repos/:owner/:repo/issues/:number
```

<div style="text-align: left"> Получить все issue</div>

```
GET /repos/:owner/:repo/issues
```

<div style="text-align: left"> Изменить issue</div>

```
PATCH /repos/:owner/:repo/issues/:number
```

<!-- v -->

А что если нужно больше 4 видов операций? Например, архивировать репозиторий
<img src="./images/Archive_repo.png" alt="Архивировать репозиторий">

<!-- v -->

Помимо типичных операций CRUD, которые мы только что рассмотрели, API REST иногда может потребовать представления операций, не относящихся к CRUD. В этом случае обычно используются следующие подходы:

<!-- v -->

#### Действие как часть поля ресурса

API GitHub использует флаг **archive** в качестве входного параметра для API редактирования репозитория, чтобы представить действие архивирования репозитория

```console
PATCH /repos/vvscode/otus--javascript-basic
HOST api.github.com
Content-Type: application/json
Authorization: token OAUTH-TOKEN
{
  "archived": true
}
```

<!-- v -->

#### Действию как саб - ресурс

API GitHub использует этот шаблон для блокировки и разблокировки проблемы.

```console
PUT /repos/:owner/:repo/issues/:number/lock
```

<!-- v -->

Некоторые операции, такие как поиск, еще сложнее вписать в парадигму REST. Типичная практика в этом случае - использовать только команду действия в URL-адресе API.

```console
GET /search/code?q=:query:
```

Пример поиска файлов в GitHub, соответствующих заданному запросу.

<!-- s -->

### Remote Procedure Call

<!-- v -->

**Удаленный вызов процедур (RPC)** - это одна из простейших парадигм API, в которой клиент выполняет блок кода на другом сервере.

<!-- v -->

В то время как **REST** рассматривает ресурсы, RPC касается действий. Клиенты обычно передают имя метода и аргументы серверу и получают обратно JSON или XML.

<!-- v -->

API RPC обычно следуют двум простым правилам:

- endpoint-ы содержат имя выполняемой операции
- вызовы API выполняются с помощью наиболее подходящего HTTP-глагола: GET для запросов чтения и POST для других
  <!-- v -->
  Стиль RPC отлично подходит для API, которые предоставляют различные действия, которые могут иметь больше нюансов и сложностей, чем может быть инкапсулировано с помощью CRUD
  <!-- v -->
  Пример HTTP запроса к Slack API

```console
POST /api/conversations.archive
HOST slack.com
Content-Type: application/x-www-form-urlencoded
Authorization: Bearer xoxp-1650112-jgc2asDae
```

API позволяет выполнять несколько действий, таких как архивирование, присоединение, удаление, выход и переименование. Хотя в этом случае есть явный «ресурс», не все эти действия хорошо вписываются в шаблон REST.

<!-- v -->
<img src="./images/slack_conversation_API.png" alt="Slack conversation API">
<!-- s -->

### GraphQL

<!-- v -->

GraphQL - это язык запросов для API, который в последнее время приобрел значительную популярность.

Он был разработан внутри Facebook в 2012 году до публичного выпуска в 2015 году и был принят поставщиками API, такими как GitHub, Yelp и Pinterest.

<!-- v -->

GraphQL позволяет клиентам определять структуру требуемых данных, и сервер возвращает именно эту структуру.

GraphQL query

```console
{
    user(login: "saurabhsahni") {
      id
      name
      company
      createdAt
    }
}
```

Response from GitHub GraphQL API

```console
{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjY1MDI5",
      "name": "Saurabh Sahni",
      "company": "Slack",
      "createdAt": "2009-03-19T21:00:06Z"
    }
  }
}
```

<!-- v -->

В отличие от REST и RPC API, GraphQL API требует только одну конечную точку URL. Точно так же вам не нужны разные HTTP-команды для описания операции. Вместо этого вы указываете в теле JSON, выполняете ли вы запрос или мутацию.

<!-- v -->

#### GraphQL имеет несколько ключевых преимуществ перед REST и RPC:

<!-- v -->

GraphQL позволяет вкладывать запросы друг в друга и запрашивать данные с разных источников за один запрос. Без GraphQL может понадобиться множество HTTP вызовов на сервер.

<!-- v -->

Нет управления версиями  
Вы можете добавлять новые поля и типы в GraphQL API, не затрагивая существующие запросы. Точно так же проще отказаться от использования существующих полей.

<!-- v -->

Ничего лишнего  
Благодаря GraphQL, поскольку клиенты могут точно указать, что им нужно, размеры полезной нагрузки могут быть меньше.

<!-- v -->

Строго типизированный  
GraphQL строго типизирован. Во время разработки проверка типов GraphQL помогает гарантировать, что запрос синтаксически верен и действителен.

<!-- v -->

Самодокументированность
Хотя существуют внешние решения, такие как Swagger, которые помогают упростить изучение REST API, в GraphQL изначально поставляется с GraphQL, встроенной в браузер IDE для изучения GraphQL.

<!-- v -->

#### Что, одни плюсы?!

<!-- v -->

#### Минусы:

- Хотя GraphQL имеет множество преимуществ, одним из его недостатков является сложность, которую он добавляет поставщику API.
- Серверу требуется дополнительная обработка для анализа сложных запросов и проверки параметров.
- Оптимизация производительности запросов GraphQL тоже может быть сложной задачей.

<!-- v -->

Для внутренних нужд компании легко предсказать варианты использования и отладить узкие места в производительности. При работе с внешними разработчиками эти варианты использования становятся трудными для понимания и оптимизации.

<!-- v -->

#### Резюмируем

<img src="./images/comparision2.png" alt="Сводная таблица различий 3 подходов">

<!-- s -->

### XMLHttpRequest vs fetch

<!-- v -->

Следующий код JavaScript показывает базовый HTTP-запрос GET для http://www.7timer.info с использованием XMLHttpRequest (обычно сокращается до XHR):

```javascript
const xhr = new XMLHttpRequest();
xhr.open(
  "GET",
  "http://www.7timer.info/bin/astro.php?lon=113.2&lat=23.1&output=json"
);
// Подписываемся на изменение состояния запроса
xhr.onreadystatechange = function () {
  // Проверка, завершилось ли выполнение запроса?
  if (xhr.readyState !== 4) return;

  if (xhr.status === 200) {
    // Обработка удачного выполнения запроса
    console.log(xhr.responseText);
  } else {
    // Обработка ошибки
    console.log("HTTP error", xhr.status, xhr.statusText);
  }
};
// Отправляем запрос
xhr.send();
```

<!-- v -->

Объект XMLHttpRequest имеет много других параметров, событий и свойств ответа. Например, тайм-аут в миллисекундах может быть установлен и обнаружен:

```javascript
// установка timeout
xhr.timeout = 3000; // 3 секунды
xhr.ontimeout = () => console.log("timeout", xhr.responseURL);
```

<!-- v -->

и событие progress может сообщить о длительной загрузке файла:

```javascript
xhr.upload.onprogress = (p) => {
  console.log(Math.round((p.loaded / p.total) * 100) + "%");
};
```

<!-- v -->

Также запрос XHR легко завершить с помощью `xhr.abort()` и, при необходимости, обнаружить такое событие с помощью функции `xhr.onabort`.

<!-- v -->

Число параметров может вызывать недоумение, и ранние реализации XMLHttpRequest имели несколько кросс-браузерных несоответствий. По этой причине большинство библиотек и сред предлагают функции-оболочки Ajax для решения этих проблем, например, метод jQuery.ajax():

```javascript
$.ajax("http://domain/service")
  .done((data) => console.log(data))
  .fail((xhr, status) => console.log("error:", status));
```

<!-- v -->

**Fetch** API является современной альтернативой XMLHttpRequest. Универсальные интерфейсы Headers, Request и Response обеспечивают согласованность, в то время как Promises позволяют упростить цепочки и async/await без обратных вызовов.

<!-- v -->

Приведенный выше пример XHR можно преобразовать в гораздо более простой код на основе Fetch, который даже анализирует возвращенный JSON:

```javascript
fetch("http://domain/service", { method: "GET" })
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.error("error:", error));
```

<!-- v -->

Fetch - чистый, элегантный и простой для понимания. Почему бы нам не использовать его вместо древнего XMLHttpRequest?

<!-- v -->

Fetch API достаточно хорошо поддерживается, но он не будет работать во всех выпусках Internet Explorer. Люди, использующие версии Chrome, Firefox и Safari старше 2017 года, также могут испытывать проблемы.

<!-- v -->

Удивительно, но ошибка HTTP, такая как **404 Page Not Found** или **500 Internal Server Error**, не попадет в `.catch()`. Обычно он разрешается с состоянием response.ok, установленным в false.

<!-- v -->

#### Отмена запроса

Прекращение отправки было невозможно в течение нескольких лет, но теперь оно поддерживается в браузерах, которые реализуют API `AbortController`. Это запускает сигнал, который может быть передан объекту инициации Fetch:

```javascript
const controller = new AbortController();
fetch('http://domain/service', {
   method: 'GET'
   signal: controller.signal
})
   .then( response => response.json() )
   .then( json => console.log(json) )
   .catch( error => console.error('Error:', error) );
```

Обработка может быть прервана вызовом controller.abort(). Будет вызвана функция `.catch()`.

<!-- v -->

#### Нет прогресса

На момент написания, Fetch не поддерживает события прогресса. Поэтому невозможно сообщить о статусе загрузки файлов или аналогичных представлений больших форм.

<!-- s -->

### Рассмотрим REST поближе

<!-- v -->

**что значит RESTful**

- Client-Server
- Stateless
- Cache
- Uniform Interface
- Layered System
- Code-On-Demand (опционально)
<!-- v -->

#### Client-Server

- **клиенты** не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается
- **серверы** не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы
<!-- v -->

#### Stateless

Сервер не должен хранить какой-либо информации о клиентах и последних запросах. Каждый запрос - как новый. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента. No session, no history.

<!-- v -->

#### Cache

Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.

<!-- v -->

#### Uniform Interface

- Identification of resources
- Manipulation of resources through representations
- Self-descriptive messages
- HATEOAS
<!-- v -->

#### Layered System

Многоуровневость достигается за счёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.

<!-- v -->

#### Code-On-Demand (опционально)

REST позволяет наращивать функциональность клиентского приложения по мере необходимости при помощи скачивания и исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, уменьшая количество заранее написанных возможностей.

<!-- s -->
